<!DOCTYPE html>
<html lang="nl">
    
<head>
<meta charset="UTF-8">
<title>Verborgen aanwijzing</title>
    
<style>
body {
    font-family: 'Arial Black', Arial, sans-serif;
    margin: 0;
    height: 100vh;
    background-image: url('Foto%202024.jpg');
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    position: relative;
}

/* Overlay container voor tekst */
.overlay {
    position: absolute;
    top: 5%;             /* verticale positie vanaf bovenkant */
    left: 50%;            /* horizontaal midden van het scherm */
    transform: translateX(-50%); /* verschuif de div terug zodat hij echt gecentreerd is */
    color: white;
    /* background-color: rgba(255, 0, 0, 0.5); /* halfdoorzichtig rood */
    text-align: center;   /* tekst binnen de overlay gecentreerd */
    text-shadow: 2px 2px 8px rgba(0,0,0,0.5);
    width: 75%;
    max-width: 100%;        /* voorkomt dat tekst te breed wordt */
}

/* Titel */
h1 {
    font-size: 4em;
    margin-bottom: 0.5em;
}

/* Countdown */
#countdown {
    font-size: 4.5em;
    font-weight: bold;
    letter-spacing: 0.05em;
    animation: pulse 1s infinite alternate;
}

/* Pulse animatie */
@keyframes pulse {
    from { transform: scale(1); }
    to { transform: scale(1.05); }
}

/* Bericht */
#message {
    margin-top: 15px;
    font-size: 2.5em;
    text-shadow: 1px 1px 5px rgba(0,0,0,0.3);
    max-width: 100%;          /* tekst mag maximaal 80% van overlay zijn */
    word-wrap: break-word;   /* lange woorden breken indien nodig */
    text-align: center;      /* tekst gecentreerd */
    line-height: 1.4em;      /* iets meer ruimte tussen regels voor leesbaarheid */
}

/* Media queries voor kleinere schermen */
@media (max-width: 768px) { /* tablets */
    h1 { font-size: 2.8em; }
    #countdown { font-size: 3em; }
    #message { font-size: 2em; }
}

@media (max-width: 480px) { /* smartphones */
    .overlay { top: 5%; left: 5%; }
    h1 { font-size: 2em; }
    #countdown { font-size: 2.3em; }
    #message { font-size: 1.5em; }
}
</style>
    
<script>
/*
  Strikte server-time-only countdown.

  - Geen gebruik van Date.now() of lokale systeemklok voor "now".
  - serverTimeAtSyncMs = absolute server timestamp (ms since epoch) verkregen van API.
  - perfNowAtSync = performance.now() op exact hetzelfde sync-moment.
  - correctedNow = serverTimeAtSyncMs + (performance.now() - perfNowAtSync).
  - Final server-confirmatie (no-store fetch) vóór redirect.
*/

const REDIRECT_URL = 'https://bbfl.formaloo.co/bbfl_aanwijzing';
const TARGET_ISO = '2025-11-01T22:30:00+02:00'; // doel - blijf in UTC-offset-formaat
const TIME_API = 'https://worldtimeapi.org/api/timezone/Europe/Brussels';
const SYNC_INTERVAL_MS = 30_000;      // elke 30s resync; verlaag/verhoog naar wens
const FINAL_CONFIRM_TIMEOUT_MS = 3000; // timeout voor finale confirm

// --- Intern state ---
let serverTimeAtSyncMs = null;  // ms since epoch (parsed from server response)
let perfNowAtSync = null;       // performance.now() at sync moment
let finalConfirmOngoing = false;
const targetMs = Date.parse(TARGET_ISO); // parse once; dit gebruikt géén lokale "now"

// Helper: doe een tijd-sync met latency-correctie (halve RTT)
async function syncWithServer() {
  try {
    // performance timers voor monotone RTT schatting
    const t0 = performance.now();
    const resp = await fetch(TIME_API, { cache: 'no-store' });
    const t1 = performance.now();

    if (!resp.ok) throw new Error('time API niet bereikbaar: ' + resp.status);
    const data = await resp.json();

    // parse server timestamp (ISO) naar ms sinds epoch
    const serverMs = Date.parse(data.datetime); // OK om te parsen; dit is server-absolute tijd

    // perf midpoint
    const perfMid = (t0 + t1) / 2;

    serverTimeAtSyncMs = serverMs;
    perfNowAtSync = perfMid;

    console.log('[sync] ok; serverMs=', serverMs, 'perfMid=', perfMid, 'rtt=', (t1 - t0));
    return true;
  } catch (err) {
    console.warn('[sync] mislukt:', err);
    return false;
  }
}

// Berekent "nu" zonder ooit Date.now() of lokale clock te gebruiken:
function correctedNowMs() {
  if (serverTimeAtSyncMs === null || perfNowAtSync === null) {
    // geen sync gedaan — return null zodat UI kan tonen dat we niet gesynchroniseerd zijn
    return null;
  }
  // performance.now() is monotone en niet beïnvloedbaar door het zetten van de systeemklok
  return serverTimeAtSyncMs + (performance.now() - perfNowAtSync);
}

// UI helper
function pad2(n) { return String(n).padStart(2, '0'); }

function updateUI() {
  const nowMs = correctedNowMs();
  if (nowMs === null) {
    document.getElementById('countdown').textContent = '-- : -- : --';
    document.getElementById('message').textContent = 'Bezig met synchroniseren...';
    return;
  }

  const diffMs = targetMs - nowMs;
  if (diffMs <= 0) {
    // Toon 00:00:00 en start finale server-confirmatie
    document.getElementById('countdown').textContent = '00 : 00 : 00';
    document.getElementById('message').textContent = 'Verifiëren...';
    finalizeAndRedirect();
    return;
  }

  const totalSeconds = Math.floor(diffMs / 1000);
  const hours = Math.floor(totalSeconds / 3600);
  const minutes = Math.floor((totalSeconds % 3600) / 60);
  const seconds = totalSeconds % 60;

  document.getElementById('countdown').textContent =
    `${pad2(hours)} : ${pad2(minutes)} : ${pad2(seconds)}`;

  document.getElementById('message').textContent =
    'Jullie zijn te vroeg, er wordt nog volop gezocht op deze plaats door de politie. Kom terug wanneer de politie deze zone vrijgegeven heeft!';
}

// Voer een finale check uit bij server: alleen redirecten als servertijd >= target
async function finalizeAndRedirect() {
  if (finalConfirmOngoing) return;
  finalConfirmOngoing = true;

  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), FINAL_CONFIRM_TIMEOUT_MS);

  try {
    const resp = await fetch(TIME_API, { cache: 'no-store', signal: controller.signal });
    clearTimeout(id);
    if (!resp.ok) throw new Error('final time API response not ok: ' + resp.status);
    const data = await resp.json();
    const serverMs = Date.parse(data.datetime);
    if (serverMs >= targetMs) {
      // server bevestigt — redirecteren
      window.location.href = REDIRECT_URL;
    } else {
      // server zegt nog niet voorbij — update lokale sync state (her-synchroniseer netjes)
      // gebruik serverMs and perf midpoint approximation by performing a full sync to get perf baseline
      await syncWithServer();
      updateUI();
    }
  } catch (err) {
    console.warn('[finalize] confirm failed:', err);
    // toon duidelijke foutmelding en blijf proberen in de hoofdloop
    document.getElementById('message').textContent =
      'Kon final server-check niet uitvoeren — pagina blijft zichtbaar. Probeer refresh.';
  } finally {
    finalConfirmOngoing = false;
  }
}

// Start de hele teller: initial sync + UI-interval + periodieke resync + visibility handling
async function startStrictCountdown() {
  // initial sync - wacht hier maximaal kort; als faalt tonen we message en blijven proberen
  const ok = await syncWithServer();
  if (!ok) {
    document.getElementById('message').textContent =
      'Kon serversynchronisatie niet uitvoeren. Controleer netwerk. Geen lokale klok gebruikt.';
  }

  // update UI elk seconde (zelfde monotone basis)
  updateUI();
  const uiInterval = setInterval(updateUI, 1000);

  // periodieke resync met server om latency/delta te corrigeren
  const resyncInterval = setInterval(async () => {
    const success = await syncWithServer();
    if (success) updateUI();
  }, SYNC_INTERVAL_MS);

  // Bij terug naar foreground: forceer een snelle resync (non-blocking)
  document.addEventListener('visibilitychange', () => {
    updateUI();
    if (document.visibilityState === 'visible') {
      syncWithServer().then(() => updateUI()).catch(()=>{});
    }
  });

  // cleanup
  window.addEventListener('beforeunload', () => {
    clearInterval(uiInterval);
    clearInterval(resyncInterval);
  });
}

// Start onload
window.addEventListener('load', startStrictCountdown);
</script>

    
</head>
    
<body>
  <div class="overlay">
    <h1>Verborgen aanwijzing</h1>
    <div id="countdown">-- : -- : --</div>
    <div id="message">
      Jullie zijn te vroeg, er wordt nog volop gezocht op deze plaats door de politie. Kom terug wanneer de politie deze zone vrijgegeven heeft!
    </div>
  </div>
</body>



























